#!/bin/bash
# File Activity inotify manager
#
# Copyright 2020-2025 Dan Landon
#
# Permission is granted to use this software for personal, educational, or internal use only.
# Commercial use, redistribution, or modification of this software or any derived works
# is strictly prohibited without prior written permission.
#
# THIS SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND.
#
plugin="file.activity"
inotify="file.activity.inotify"
disks_file="/tmp/${plugin}/${plugin}.disks"

PID_FILE="/var/run/${inotify}.pid"
LOG_FILE="/var/log/${plugin}.log"
event_count=0
TRIM_INTERVAL=100

PROG_NAME=${plugin}

# Define FIFO path
FIFO_PATH="/tmp/${plugin}/inotify_queue"

CONFIG="/boot/config/plugins/${plugin}/${plugin}.cfg"
source $CONFIG

if [ -z $MAX_LINES ]; then
	MAX_LINES=2000
fi

adjust_watch_limit() {
	local dir_count=0
	local count
	local required
	local current
	local new
	local old

	# Count dirs across all recycle bin mount paths
	while IFS= read -r mp || [ -n "$mp" ]; do
		[ -d "$mp" ] || continue

		count=$(find "$mp" -type d -printf '.' 2>/dev/null | wc -c)
		dir_count=$((dir_count + count))
	done < "$combined_recycle_bins"

	# Add 10% buffer
	required=$((dir_count + dir_count / 10))

	# Count current inotify watches
	current=$(find /proc/*/fd -lname anon_inode:inotify 2>/dev/null | wc -l)

	new=$((current + required))
	old=$(cat /proc/sys/fs/inotify/max_user_watches 2>/dev/null)
	old=${old:-0}

	if [ "$new" -gt "$old" ]; then
		logger -t"$PROG_NAME" "Updating max_user_watches from $old to $new"
		sysctl -qw fs.inotify.max_user_watches="$new"
	fi
}

# If file activity inotify is already running, don't run it again
if [ -e "/var/run/${plugin}.pid" ] && [ ! -e "$PID_FILE" ]; then
	# Create pid file to indicate inotify is running.
	echo $$ > "$PID_FILE"

	logger "File Activity inotify starting..." -t"$PROG_NAME"

	# Configure the disks_file based on the file activity settings.
	/usr/local/emhttp/plugins/${plugin}/scripts/configure_file_activity ${INCLUDE_SSD} ${INCLUDE_UD} ${INCLUDE_CACHE}

	# Adjust the inotify watch limit if necessary
	adjust_watch_limit

	# Convert comma-separated list into a regex alternation list.
	trimmed_regex=""
	IFS=','

	for item in $EXCLUDE_SHARES; do
		# Trim leading/trailing whitespace but keep internal spaces
		item="$(echo "$item" | sed 's/^[ \t]*//;s/[ \t]*$//')"

		if [ -n "$item" ]; then
			if [ -z "$trimmed_regex" ]; then
				trimmed_regex="$item"
			else
				trimmed_regex="${trimmed_regex}|${item}"
			fi
		fi
	done

	EXCLUDE_REGEX="$trimmed_regex"

	open_isdir=",ISDIR"

	# Cleanup function
	cleanup() {
		logger "File Activity inotify exiting..." -t"$PROG_NAME"

		# Only act if $inotify_pid is a valid running PID
		if [[ "$inotify_pid" =~ ^[0-9]+$ ]] && kill -0 "$inotify_pid" 2>/dev/null; then
			kill "$inotify_pid" 2>/dev/null
			wait "$inotify_pid" 2>/dev/null
		fi

		# Remove PID file
		rm -f "$PID_FILE"

		# Remove main task PID to stop file monitoring
		rm -f "/var/run/${plugin}.pid"

		[ -p "$FIFO_PATH" ] && rm -f "$FIFO_PATH"
		exit 0
	}

	# Set trap to clean up on exit
	trap cleanup SIGINT SIGTERM EXIT

	# Create FIFO if it doesn't exist
	[ -p "$FIFO_PATH" ] || mkfifo "$FIFO_PATH"

	# Start inotifywait and send output to FIFO
	inotifywait --monitor -rs --quiet --event "$OPEN_FILE_EVENTS"attrib,move,create,delete,modify,close_write \
		--excludei "$EXCLUDE_REGEX" \
		--timefmt '%b %d %H:%M:%S' \
		--format '%T %e => %w%f' \
		--fromfile "${disks_file}" > "$FIFO_PATH" &

	# Get the inotifywait pid.
	inotify_pid=$!

	# Read from FIFO
	while IFS= read -r line < "$FIFO_PATH"
	do
		if [ "${line/$open_isdir}" = "$line" ]; then
			# Add line to log
			echo "$line" >> /var/log/${plugin}.log

			# Count event
			event_count=$((event_count + 1))

			# Only check every TRIM_INTERVAL events
			if [ "$event_count" -ge "$TRIM_INTERVAL" ]; then
				event_count=0

				# Check line count first — avoid work if not needed
				line_count=$(wc -l < "$LOG_FILE")

				if [ "$line_count" -gt "$MAX_LINES" ]; then
					tail -n "$MAX_LINES" "$LOG_FILE" > "${LOG_FILE}.tmp" && mv "${LOG_FILE}.tmp" "$LOG_FILE" &
				fi
			fi
		fi
	done

	wait "$inotify_pid"
	status=$?

	# If exit code is non-zero AND not 143 (SIGTERM), it's abnormal
	if [ "$status" -ne 0 ] && [ "$status" -ne 143 ]; then
		logger "Error: File Activity logging has terminated unexpectedly (code $status)" -t"$PROG_NAME"

		cleanup

		exit 1
	fi
fi
